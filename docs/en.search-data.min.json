[{"id":0,"href":"/fourier/algorithms/canny/","title":"Canny Edge Detection","parent":"Algorithms","content":"There are many applications which require a fast edge detection algorithm. For example, real time object detection algorithms apply edge detection on the visual data fed to them in order to simplify the object detection.\nDespite being developed in 1986, the Canny edge detection algorithm is still at the forefront of edge detection methods. This is because it offers a very good trade-off between accuracy and speed.\nDefinition of an edge An edge is a curve in the image of roughly even intensity, such that in crossing the curve there is an abrupt change in intensity. We expect to find edges where one object ends and another begins, or at places where a sharp shadow is cast by an object.\nThe Canny Edge Detector The Canny Edge Detector follows a 5 step process which will now be outlined. To help the discussion the following image will be passed through each step of the algorithm as implemented in Fourier.\n\nFirst, the image is converted to grayscale, and a gaussian blur is applied to it. The blurring is necessary because the next step uses differentiation operators, which are very sensitive to noise.\nThe Gaussian blur removes a large amount of noise from the image, but also defocuses the edges. The blur parameters must hence be adjusted for optimal performance.\nWe are interested in places in the image \\(I\\)    where \\(|\\nabla I|\\)    is large, as this marks pixels where the intensity changes abruptly. For the next step, we will also need the direction \\(\\theta\\)    of \\(\\nabla I\\)    .\nThe Sobel kernels, defined as\n$$S_x := \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; -1 \\\\ 2 \u0026amp; 0 \u0026amp; -2 \\\\ 1 \u0026amp; 0 \u0026amp; -1 \\end{pmatrix}; \\qquad S_y := \\begin{pmatrix} 1 \u0026amp; 2 \u0026amp; 1 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \\\\ -1 \u0026amp; -2 \u0026amp; -1 \\end{pmatrix}$$     are such that \\(S_x * I \\approx \\frac{\\partial I}{\\partial x}\\)    and \\(S_y * I \\approx \\frac{\\partial I}{\\partial y}\\)    Hence\n $$|\\nabla I| = \\sqrt{(S_x * I)^2 \u0026#43; (S_y * I)^2}$$     $$\\theta = \\arctan \\bigg(\\frac{S_y * I}{S_x * I}\\bigg)$$     These definitions give us an easy and quick way to find what we need.\n"},{"id":1,"href":"/fourier/algorithms/","title":"Algorithms","parent":"Documentation","content":"Fourier implements a number of image processing algorithms. This section of the documentation is dedicated to explaining what makes these algorithms tick, not only in the context of Fourier, but in a general image processing scenario.\nConvolutions Many image processing algorithms are based on the technique of convolution. In fact, Fourier\u0026rsquo;s speed is, for the most part, limited by its implementation of convolutions.\nIf we treat a grayscale image \\(I\\)    as an \\(N\\times M\\)    matrix, its convolution with a matrix \\(K\\)    which is smaller than \\(I\\)    and has odd width \\(2 p \u0026#43; 1\\)    and odd height \\(2 q \u0026#43; 1\\)    is defined as an \\(N \\times M\\)    matrix \\(K * I\\)    such that\n$$(K * I)(i, j) = \\sum_{n=0}^{2p\u0026#43;1}\\sum_{m=0}^{2q\u0026#43;1}K(n, m)I(i - n \u0026#43; p, j - m \u0026#43; q)$$     The matrix \\(K\\)    used for convolution is called a convolution kernel, or just a kernel. Convolutions with kernels of even width or height, or a size larger than the image are left undefined for the sake of simplicity.\nThe convolution of a color image with a kernel is simply the convolution of each of its components as defined for a grayscale image.\nImmediately, there appears to be a problem with the definition, because unless the kernel is \\(1\\times 1\\)    , there will be points in the image \\(I(i, j)\\)    such that \\(i - n \u0026#43; p \u0026lt; 0\\)    , \\(i - n \u0026#43; p \\geq N\\)    , \\(j - m \u0026#43; q \u0026lt; 0\\)    or \\(j - m \u0026#43; p \\geq M\\)    .\nThere is more than one way to handle this issue. The simplest solution is to not compute the result of the convolution for pixels which are out of bound, and copy them over untouched to the convolved image. This is the approach taken by Fourier at the moment.\nFor small images or special kernels the above solution does not produce a satisfactory result. For Canny edge detection, for example, white lines usually appear around the image, because blurring the image at the start produces a sharp intensity gradient at the border of the image.\nAn alternative is to virtually \u0026ldquo;extend\u0026rdquo; the image to a new image \\(I\u0026#39;\\)    of size \\((N \u0026#43; 2p) \\times (M \u0026#43; 2q)\\)    , such that the indices of the image fall in the range \\(-p \u0026lt; i \u0026lt; N \u0026#43; p\\)    and \\(-q \u0026lt; j \u0026lt; M \u0026#43; q\\)    , and which is defined by\n$$I\u0026#39;(i, j) = I(i\u0026#39;, j\u0026#39;); \\qquad i\u0026#39; = \\begin{cases} i \u0026amp; 0 \\leq i \u0026lt; N \\\\ 0 \u0026amp; i \u0026lt; 0 \\\\ N - 1 \u0026amp; i \\geq N \\end{cases} \\qquad j\u0026#39; = \\begin{cases} j \u0026amp; 0 \\leq j \u0026lt; M \\\\ 0 \u0026amp; j \u0026lt; 0 \\\\ M - 1 \u0026amp; j \\geq M \\end{cases}$$     It should be clear that \\(I\u0026#39;\\)    is well defined in terms of \\(I\\)    , and one can then redefine the convolution as\n$$(K * I)(i, j) = \\sum_{n=0}^{2p\u0026#43;1}\\sum_{m=0}^{2q\u0026#43;1}K(n, m)I\u0026#39;(i - n \u0026#43; p, j - m \u0026#43; q)$$     This new definition works for any \\(0 \\leq i \u0026lt; N\\)    and \\(0 \\leq j \u0026lt; M\\)    .\nIn fact most strategies which handle the issue of convolution at the border of the image are based on this tactic of finding a new image \\(I\u0026#39;\\)    which is well defined in terms of \\(I\\)    , but which is larger to account for the convolution.\nAnother such strategy is to \u0026ldquo;mirror\u0026rdquo; the image: $$I\u0026#39;(i, j) = I(i\u0026#39;, j\u0026#39;); \\qquad i\u0026#39; = \\begin{cases} i \u0026amp; 0 \\leq i \u0026lt; N \\\\ -i \u0026amp; i \u0026lt; 0 \\\\ 2N - i \u0026amp; i \\geq N \\end{cases} \\qquad j\u0026#39; = \\begin{cases} j \u0026amp; 0 \\leq j \u0026lt; M \\\\ -j \u0026amp; j \u0026lt; 0 \\\\ 2M - j \u0026amp; j \\geq M \\end{cases}$$     "},{"id":2,"href":"/fourier/","title":"Documentation","parent":"","content":"Fourier is a simple Python2 demo library which implements a number of image processing algorithms in C++.\nThe performance of the library is not a priority, instead, the main aim of the library is to offer implementations which are approachable and enhance understanding of the algorithms. To this end, all algorithms run single threaded on a CPU, rather than being offloaded to a GPU.\nHere are some example images which illustrate what Fourier can be used for.\n\nGaussian blur\nAn image of a cathedral which has been convolved by a gaussian blur kernel. The original is shown on the left.  \nCanny edge detection\nAn image of a lizard. The edges in the image have been found using Canny edge detection, a multistage algorithm.  \nProcess of Canny edge detection\nThis image illustrates part of the process of canny edge detection. The original image (top left) is first converted to grayscale and a gaussian blur is applied to it (top right). The result is then convolved with the two Sobel operators (bottom left). Finally, the image is suppressed, and then double thresholding is applied to it (bottom right).  "},{"id":3,"href":"/fourier/getting_started/","title":"Getting started","parent":"Documentation","content":"This page contains a build guide for Fourier, and an overview of the functionality offered by it. For more detailed documentation, go to Algorithms.\nBuilding Fourier is tested on an Ubuntu 20.04 system using Python v2.7. The library will likely compile on Debian or Windows systems with the required dependencies, however this is not tested.\nTo build on Debian, you will need libjpeg, libpng, Make, CMake, g++, Python 2.7 and pybind11. The library can be compiled and installed by running the following commands\n# install required dependencies apt install build-essential \\  cmake \\  libpng-dev \\  libjpeg-dev \\  python2.7 \\  pybind11-dev # clone repo git clone git@github.com:MarkMizzi/fourier.git fourier cd fourier # create project Makefile in fourier/build cmake -Bbuild # go to build directory and invoke make to compile the project. cd build make Usage The C++ interface is wrapped in Python2 using pybind11, so as to make it easier to interact with the algorithms. The test folder contains example scripts which illustrate some of the functionality of the library.\nMost of the functionality of Fourier is contained in the class Image. An object belonging to this class represents an image which has been loaded from a file into memory.\nReading and Writing Image files. Fourier currently supports JPEG image files using libjpeg. These can be read from and written to using the two functions:\n# read data from an image file into the Image object x x = fourier.readJPEG(fname=\u0026#34;test_image.jpeg\u0026#34;) # the input file name x.writeJPEG(fname=\u0026#34;test_image_out.jpeg\u0026#34;, # the output file name quality=100) # the output quality Dimensions and colour space The width and height of an image can be queried using the functions\nw = x.width() h = x.height() # supposing x is an Image. Fourier uses arrays of floats called channels to store the image in memory. A float in a channel can take on a value between 0 and 255. There are no bounds checks, but applying an operation which causes pixels to exceed this range results in visual artifacts when writing to files. Floats were chosen rather than unsigned chars for two reasons; when applying a sequence of operations, floats give much more accurate results, and GPUs are optimized for use with floats, which means the library could more easily be adapted to use hardware acceleration in the future.\nImages have an attribute called their color space which determines how many channels they have, and what each channel represents. Currently the color space of an image can be RGB, RGBX, RGBA, CMYK, YCbCr, or GRAY.\nThe color space of an image can be queried by calling c_space = x.color_space() # supposing x is an Image.\nAdding and multiplying Images Fourier provides pixel-wise addition, multiplication, and exponentiation. Addition and multiplication can be performed on two images or on an image and a float, while exponentiation can only be performed on an image and a float. Any arithmetic operations produce a new Image object.\nAn exception is thrown if one attempts to perform an arithmetic operation on images which do not have the same dimensions or color space.\nAddition and multiplication between images and floats are not commutative.\n# supposing x and y are two Image objects # z will be an image such that z(ch, i, j) = x(ch, i, j) + y(ch, i, j) z = x + y # z will be an image such that z(ch, i, j) = x(ch, i, j) + 2.0 z = x + 2.0 # z will be an image such that z(ch, i, j) = x(ch, i, j) * y(ch, i, j) z = x * y # z will be an image such that z(ch, i, j) = x(ch, i, j) * 3.0 z = x * 3.0 # z will be an image such that z(ch, i, j) is the square root of x(ch, i, j) z = x ** 0.5 Fourier does not check if an arithmetic operation produces pixels of value greater than 255 or smaller than 0. If not dealt with by the library\u0026rsquo;s user, this may cause issues when writing to a file, or graphical artifacts in the image file produced.\nPrinting Image information The magic method __str__ is implemented for Image objects, and produces a string with the location of the C++ Image object in memory, as well as the dimensions and colour space of the image.\n# supposing x is an Image object print(x) # prints something like: # Image @ 0x5638583989a0 { Width: 2880, Height: 2160, Color space: RGB} # to the console The library also provides another method called dump which returns a string containing all of an Image object\u0026rsquo;s pixel data.\n"},{"id":4,"href":"/fourier/categories/","title":"Categories","parent":"Documentation","content":""},{"id":5,"href":"/fourier/tags/","title":"Tags","parent":"Documentation","content":""}]