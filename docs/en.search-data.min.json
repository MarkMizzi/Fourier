[{"id":0,"href":"/fourier/algorithms/","title":"Algorithms","parent":"Documentation","content":"Fourier implements a number of image processing algorithms. This section of the documentation is dedicated to explaining what makes these algorithms tick, not only in the context of Fourier, but in a general image processing scenario.\nConvolutions Many image processing algorithms are based on the technique of convolution. In fact, Fourier\u0026rsquo;s speed is, for the most part, limited by its implementation of convolutions.\nIf we treat a grayscale image \\(I\\)    as an \\(N\\times M\\)    matrix, its convolution with a matrix \\(K\\)    of odd width \\(2 p \u0026#43; 1\\)    and odd height \\(2 q \u0026#43; 1\\)    is defined as an \\(N \\times M\\)    matrix \\(K * I\\)    such that\n$$(K * I)(i, j) = \\sum_{m=0}^{2p\u0026#43;1}\\sum_{n=0}^{2q\u0026#43;1}K(m, n)I(i - m \u0026#43; p, j \u0026#43; n - q)$$     The convolution of a grayscale image with a matrix that has even width or even height is undefined. The matrix \\(K\\)    used for convolution is called a convolution kernel, or just a kernel.\nThe convolution of a color image with a kernel is simply the convolution of each of its components as defined for a grayscale image.\n"},{"id":1,"href":"/fourier/","title":"Documentation","parent":"","content":"Fourier is a simple Python2 demo library which implements a number of image processing algorithms in C++.\nThe performance of the library is not a priority, instead, the main aim of the library is to offer implementations which are approachable and enhance understanding of the algorithms. To this end, all algorithms run single threaded on a CPU, rather than being offloaded to a GPU.\nHere are some example images which illustrate what Fourier can be used for.\n\nGaussian blur\nAn image of a cathedral which has been convolved by a gaussian blur kernel. The original is shown on the left.  \nCanny edge detection\nAn image of a lizard. The edges in the image have been found using Canny edge detection, a multistage algorithm.  \nProcess of Canny edge detection\nThis image illustrates part of the process of canny edge detection. The original image (top left) is first converted to grayscale and a gaussian blur is applied to it (top right). The result is then convolved with the two Sobel operators (bottom left). Finally, the image is suppressed, and then double thresholding is applied to it (bottom right).  "},{"id":2,"href":"/fourier/getting_started/","title":"Getting started","parent":"Documentation","content":"This page contains a build guide for Fourier, and an overview of the functionality offered by it. For more detailed documentation, go to Algorithms.\nBuilding Fourier is tested on an Ubuntu 20.04 system using Python v2.7. The library will likely compile on Debian or Windows systems with the required dependencies, however this is not tested.\nTo build on Debian, you will need libjpeg, libpng, Make, CMake, g++, Python 2.7 and pybind11. The library can be compiled and installed by running the following commands\n# install required dependencies apt install build-essential \\  cmake \\  libpng-dev \\  libjpeg-dev \\  python2.7 \\  pybind11-dev # clone repo git clone git@github.com:MarkMizzi/fourier.git fourier cd fourier # create project Makefile in fourier/build cmake -Bbuild # go to build directory and invoke make to compile the project. cd build make Usage The C++ interface is wrapped in Python2 using pybind11, so as to make it easier to interact with the algorithms. The test folder contains example scripts which illustrate some of the functionality of the library.\nMost of the functionality of Fourier is contained in the class Image. An object belonging to this class represents an image which has been loaded from a file into memory.\nReading and Writing Image files. Fourier currently supports JPEG image files using libjpeg. These can be read from and written to using the two functions:\n# read data from an image file into the Image object x x = fourier.readJPEG(fname=\u0026#34;test_image.jpeg\u0026#34;) # the input file name x.writeJPEG(fname=\u0026#34;test_image_out.jpeg\u0026#34;, # the output file name quality=100) # the output quality Dimensions and colour space The width and height of an image can be queried using the functions\nw = x.width() h = x.height() # supposing x is an Image. Fourier uses arrays of floats called channels to store the image in memory. A float in a channel can take on a value between 0 and 255. There are no bounds checks, but applying an operation which causes pixels to exceed this range results in visual artifacts when writing to files. Floats were chosen rather than unsigned chars for two reasons; when applying a sequence of operations, floats give much more accurate results, and GPUs are optimized for use with floats, which means the library could more easily be adapted to use hardware acceleration in the future.\nImages have an attribute called their color space which determines how many channels they have, and what each channel represents. Currently the color space of an image can be RGB, RGBX, RGBA, CMYK, YCbCr, or GRAY.\nThe color space of an image can be queried by calling c_space = x.color_space() # supposing x is an Image.\nAdding and multiplying Images Fourier provides pixel-wise addition, multiplication, and exponentiation. Addition and multiplication can be performed on two images or on an image and a float, while exponentiation can only be performed on an image and a float. Any arithmetic operations produce a new Image object.\nAn exception is thrown if one attempts to perform an arithmetic operation on images which do not have the same dimensions or color space.\nAddition and multiplication between images and floats are not commutative.\n# supposing x and y are two Image objects # z will be an image such that z(ch, i, j) = x(ch, i, j) + y(ch, i, j) z = x + y # z will be an image such that z(ch, i, j) = x(ch, i, j) + 2.0 z = x + 2.0 # z will be an image such that z(ch, i, j) = x(ch, i, j) * y(ch, i, j) z = x * y # z will be an image such that z(ch, i, j) = x(ch, i, j) * 3.0 z = x * 3.0 # z will be an image such that z(ch, i, j) is the square root of x(ch, i, j) z = x ** 0.5 Fourier does not check if an arithmetic operation produces pixels of value greater than 255 or smaller than 0. If not dealt with by the library\u0026rsquo;s user, this may cause issues when writing to a file, or graphical artifacts in the image file produced.\nPrinting Image information The magic method __str__ is implemented for Image objects, and produces a string with the location of the C++ Image object in memory, as well as the dimensions and colour space of the image.\n# supposing x is an Image object print(x) # prints something like: # Image @ 0x5638583989a0 { Width: 2880, Height: 2160, Color space: RGB} # to the console The library also provides another method called dump which returns a string containing all of an Image object\u0026rsquo;s pixel data.\n"},{"id":3,"href":"/fourier/categories/","title":"Categories","parent":"Documentation","content":""},{"id":4,"href":"/fourier/tags/","title":"Tags","parent":"Documentation","content":""}]